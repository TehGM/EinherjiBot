@implements IDisposable
@inject ITimestampFormatter Formatter

<span>
    @if (this.EnableTooltip)
    {
        <MudTooltip Delay="300" Placement="Placement.Top" Color="Color.Dark">
            <TooltipContent>
                <InlineTimestamp Timestamp="this.Timestamp" Format="this.TooltipFormat" EnableTooltip="false" 
                    Style="@this.TooltipStyle" CssClass="@this.TooltipCssClass" DisableHighlight="true" />
            </TooltipContent>
            <ChildContent>
                @this.Render()
            </ChildContent>
        </MudTooltip>
    }
    else
    {
        @this.Render()
    }
</span>

@code {
    [Parameter, EditorRequired]
    public DateTime Timestamp { get; set; }
    [Parameter]
    public bool EnableTooltip { get; set; } = false;
    [Parameter]
    public TimestampFormat Format { get; set; } = TimestampFormat.RelativeLowPrecision;
    [Parameter]
    public TimestampFormat TooltipFormat { get; set; } = TimestampFormat.FullDateTimeWithSeconds;

    [Parameter]
    public bool DisableHighlight { get; set; } = false;
    [Parameter]
    public string Style { get; set; }
    [Parameter]
    public string CssClass { get; set; }
    [Parameter]
    public string TooltipStyle { get; set; }
    [Parameter]
    public string TooltipCssClass { get; set; }

    private CancellationTokenSource _cts;
    private string _computedCssClass;

    protected override void OnParametersSet()
    {
        this._computedCssClass = $"inline-timestamp {(this.DisableHighlight ? "no-highlight" : null)} {this.CssClass}";
        this.StartUpdateLoop();
        base.OnParametersSet();
    }

    private void StartUpdateLoop()
    {
        if (this.RenderLocation.IsServer)
            return;

        lock (this)
        {
            this.Dispose();

            if (this.Format != TimestampFormat.RelativeLowPrecision
                && this.Format != TimestampFormat.RelativeMediumPrecision
                && this.Format != TimestampFormat.RelativeHighPrecision)
                return;

            this._cts = new CancellationTokenSource();
            int delay = this.Format == TimestampFormat.RelativeHighPrecision ? 1 : 60;
            int firstDelay = this.Format == TimestampFormat.RelativeLowPrecision ? 10 : 1;
            _ = this.RelativeUpdateLoop(firstDelay, delay, this._cts.Token);
        }
    }

    private async Task RelativeUpdateLoop(int firstDelay, int delay, CancellationToken cancellationToken)
    {
        firstDelay = firstDelay * 1000 - 5;
        delay = delay * 1000 - 5;
        try
        {
            await Task.Delay(firstDelay, cancellationToken);
            while (!cancellationToken.IsCancellationRequested)
            {
                await this.InvokeAsync(base.StateHasChanged);
                await Task.Delay(delay, cancellationToken);
            }
        }
        catch (OperationCanceledException) { }
    }

    private RenderFragment Render()
    {
        string text = this.Formatter.Format(this.Timestamp, this.Format);
        return @<span class="@this._computedCssClass" style="@this.Style">@text</span>;
    }

    public void Dispose()
    {
        try { this._cts?.Cancel(); } catch (ObjectDisposedException) { }
        try { this._cts?.Dispose(); } catch (ObjectDisposedException) { }
    }
}
